게임 서버 프로그래밍 (03/12)
	원성연 (2013182027)

	서버용 운영체제의 종류
		여러분들이 게임 서버를 만드는데, 운영체제를 선택해야해요. 게임 클라를 만들때, 옛날에는 MMORPG를 돌린다 이거는 클라가 PC에서 돌아가죠?, 그니까 닥치고 윈도우죠... 
		하지만 요즘은 PC에서 돌리는 거 안드로이드 돌리는거, 애플에서 돌리는 거...!

		마찬가지로, 서버도 하드웨어는 정해져 있고, 프로그래밍은 동일함!. 제온에서 돌리던거 에픽에서 돌려도 잘 돌아가고, 반대도 잘됨.
		어 CPU는 차이가 없고, AMD고를까, 인텔고를까는 굳이 의미가 없고,
		근데 운영체제는 두개가 남았어..

		1. 유닉스계열
			- 리눅스, freeBSD. Solaris, OSx
			- 가격이 저렴하다. (리눅스 무료)
			- 유지 보수 관리가 어렵다. ( 잘 아는 사람이 필요하다.)

		2. 윈도우계열
			- windows 2008, 2012, 2016...
			- 비싸다... (천만원 정도 된다는데..... 서버 여러개면 오바야...)
			- 유지 보수 관리가 비교적 쉽다. (배우기 쉽다. 신경 쓸 것이 적다.)


		성능은 거기서 거기,,, 아무생각없으면 윈도우가 빠르고, 커널 커스텀할 수 있으면 유닉스가 빠름.....ㅎ

		윈도우 10 이런거 못쓰고, 윈도우 서버 2008, 2012 이런거를 사용해야함.
		운영체제는 커널이라는 것이 있는데, 윈도우 10이나 윈도우 서버나 커널을 동일한데, 서버는 편의성, 호환성 툴, 등 부가기능을 들어냄. 게임서버를 만드는데 꼭 필요하지 않은 거는 제거함.
		(따라서 메모리 절약, 전력 절약, 안정성이 높음, 보안성도 뛰어남... (이것저것 깔린게 많으면 구멍이 많은 것...)
		윈도우 10을 사서 막 들어내면 서버하고 솔직히 똑같은데, 이러니까 마소가 으악해서, 팔아먹으려고 윈도우 10은 CPU 1개밖에 안사용하도록 변경...
		2000년대 초반에는 마이크로소프트가 미친 짓...! 동접에 따른 비용을 내라...	

		우리나라는 최초 윈도우를 썻는데 성공해서 윈도우 사용함.... 하지만 점점 리눅스 사용많이함...!


	프로그램 최적화
		1. 첫번 째, 꼭 필요한 일만 하기
			- 시스템 호출 최소화 (new/delete 포함)
			- 운영체제 함부로 호출하면 안됨!!
				- FileIO, printf, scanf, window API, Network IO (<- 이건 어쩔 수 없음), 메모리 관리(new/delete) - 절대 사용핮미
				- 절대로 시스템 콜을 하면 안됨...!
				- File IO는 절대 하면 안됨... 디스크 속도에 맟춰서 오바임
				- new / delete 대신, 메모리 풀 활용.

		2. 두번 째, 좋은 알고리즘 사용하기 O()
			- 클라이언트는 굳이 빅O까지 따지지 않아도 되는데, 서버는 이게 무궁한 영향을 끼침....!
			- 동접 5000이면.... 제곱만해도 2500만...ㅎ

		3. 세번 째, 메모리 복사 줄이기
			- call by value , call by Reference or call by pointer.
			- copy Constructor 사용 회피. (move Constructor 혹은, emplace)

		4. 네번 째, HW 영향 고려
			- 캐시, 파이프라인 (보기좋은게 아니라, 우겨넣어야함)

		5. 다섯번 째, 멀티쓰레드 프로그래밍!

	성능 향상 실습
		- 시스템 콜
		- 캐시
		- 파이프라이닝


		1. 시스템 콜 부하 테스트.
			this_thread::yield(); // 저말고 다른 쓰레드에게 일을 할당해주세요! 저는 괜찮아요! ( 예제는 싱글 쓰레드이기 때문에, 아무것도 안하고 리턴한다고 보면 됨)
			
			#include <iostream>
			#include <chrono>
			#include <Windows.h>
			using namespace std;
			using namespace chrono;

			int main()
			{
			volatile int tmp = 0;
			auto start = high_resolution_clock::now();
						for (int j=0;j<10000000;++j) {
						tmp += j;
						this_thread::yield();  <<---- 아무것도 안하는 것 조차... 200배 느림.... 시스템 콜(운영체제 호출을) 하면 안된다.....
						}

			auto duration = high_resolution_clock::now() - start;
			cout << "Time " << duration_cast<milliseconds>(duration).count();
			cout << " msec\n";
			cout << "RESULT " << tmp << endl;
			}

		
		2. 캐시 미스..

			// 사이즈가 커질 수록, 캐시 미스확률이 높기 때문에,, 실행 속도가 2배 3배 넘게 차이남...
			// 캐시 안에 들어가면 속도가 제 속도가 나옴.. 근데 캐쉬 크기를 벗어나는 순간, (캐쉬 안에 명령어, i, temp 등도 들어감) 속도가 2배 3배이상 느려지게 됨...

			for (int i=0; i<21; ++i) {
						int size = 1024 << i;
						char *a = (char *) malloc(size);
						unsigned int index = 0;
						volatile unsigned int tmp=0;
						auto start = high_resolution_clock::now();
						
						for (int j=0;j<100000000;++j) {			// 1억번 루트를 돌면서, a라는 배열에서, 값을 읽어서 temp에 더하는 것.
						tmp += a[index % size];				// 인덱스는 임의의 숫자...! size는 배열의 크기!!
						index += CACHE_LINE_SIZE * 11;			
						}

			auto dur = high_resolution_clock::now() - start;
			} 


		3. Pipeline stall
			- branch miss : 조건부 분기와 분기 예측 실패, 단순 CPU 쿨럭은 매크로 함수가 더 빠른뎀....
			- 파이프라인 스칼라! : 3배빠ㅡㄹ고 이게 20개 있어서 60개인데,,, 분기 예측 터지면 1배로 바뀜...

			#define abs(x) (((x) > 0) ? (x) : - (x) )
					VS
			static long abs(long x)
			{
				long y;
				y = x >> 31;
				return (x^y) - y;
			}

			x가 0보다 크면, 0000000000000... ,  x가 1보다 크면, 11111111.... 2의 보수.

			인라인 매크로 함수보다.... 아래 함수가 10배이상 빠름...
			if문은 파이프라인 스톨!!

			move ax, arr[bx]
			cmp ax, 0
			jump plus		// -> 조건부 브랜치 명령이고, 파이프라인에서 다음명령을 패치할때, 미리 알 수 없기 때문에, 메모리의 값이 cpu에 올라오기 전에는 , 어디로 갈 지 알수가 없음.
			regate ax			// -> cpu가 기다려? // 아닝 안기다리고 일단 찍고, 다시와서 계산하고, 여기서 감...(분기 예측), -- 실패하면 다시 처음부터 원래대로 가야함... 이게 뭐여..
			
			plus: add [tmp], ax


	정리

		게임서버의 최적화는 HW를 고려해야한다.

		- 컴퓨터 구조에서 배운 것을 실제로 고려해야한다.
		- System Call 하지 말기
		- cache 잘 사용하기
			- 가능하면 메모리 적게 사용하기
		- 멀티 쓰레드 프로그래밍!
	

/////----

네트웍 기초

	딱 3가지만 짚고 넘어가면 됨.

	Computer Network
	Packet
	socket

	1. computer Network
		컴퓨터 연결하는 것. 1000 Base - T (이더넷), Wi-FI(와이파이), LTE(3G,4G)

	2. Packet
		네트웍, 그것은 연결이죠!
		여겨로디었다가 이게 뭐냐, 이거는 데이터를 주고 받는거! 이게 연결되었다를 애기하는 거고.

		데이터를 주고받을 때, 어떻게, 포맷은 뭐냐... 데이터는 이진이죠 0 1 0 10 1, 어떤 포맷으로 주고받느냐 그것이 패킷이에요.
		
		Easy Error detection : 쉬운 에러 처리.

		Host Addressing : 주소 전송

		Line Sharing : 컴퓨터랑 기지국사이에 선이 몇개나 있는가.

	3. 인터넷 프로토콜 종류..

	4. 인터넷 프로토콜 suite.. 어플리케이션 계층에서 어떻게 만들것인가가 중요함..

	여러분들은 다른 3계층은 이미 운영체제에 구현되어 있고. 어플리케이션 계층만 잘하면 됌....!

	// 패킷의 저 크기를 알수도 없고, 컴퓨터 안의 패킷 그런거 필요없고, 여러분의 사이즈를 갖고 있으면 됨!!! send와 receive가 1대1 매치잉 아님...! 그렇기 때문에 받은 거를 재조립해야함.

	따라서 헤더가 있음..
	length type 
	short buf[256]
	buf[0] = length;
	buf[1] = type;
	buf[2] = any other INFO;

	패킷을 정의하는 방법은 크게 두가지임!	

	1. 배열에 넣어서 보내는 방법.
		a. 채팅
		length (0~2) // type (2~4) // to whom (4~8) // text (8~)
		b. 움직임. ( 가속도 같은 것도 ㅣㅇㅆ어요!!!)
		length // type // x, y, z // dx, dy, dz // ax, ay, az , h//

	2. 뭐 그렇게 하냐 스트럭쳐 구조체로 하자..

	비교...!

		어느게 더 좋은 방법이느냐, 장단점이 있음
		스트럭쳐는 프로그래밍 하기가 쉽고편하다, // 호환성이 없음... 다른 언어를 쓴다... // 유연성이 떨어짐 ( 채팅 메세지 몇 바이트인지 알 수 있어?? - 낭비야. ) <<- 리니지 2 레볼루션
		배열은 프로그래밍하기 어렵고, 귀찮다... 다만 다른 언어, 다른 운영체제, 다른 CPU에서는 호환성을 어느정도 보장할 수 있음. // <<- 리니지 1
	
	위 두개의 장점만 사용한 것!
	Example : Protocol Buffer <- 성능이 그렇게 좋지 않음 물론 그렇다고 완전히 개판은 아님.,, Flat Buffer <- 그래서 나온거... 성능 하나는 오짐.

	!!! 클라이언트 팀하고 서버팀하고 데이터 어떻게 주고받을지를 맨 처음 정하고,, 그것을 프로토콜 정의!!! ( 책임 소재를 명확하게 할 수 있음)


  소켓!!
	표준이 됨. BSD Unix에서 대학원생이 만들었는데, 너무 잘만들어서 표준이 됨. FILE IO랑 거의 같음...! 랜덤 엑세스 여부 다름,
	tcp, udp 두개가 있음... 우리는 tcp만 할꺼고, udp는 다루지 않을 거임.

	관련 함수들은 Socket API라고 하고, 대부분 시스템 콜 함수들임.


	원래 소켓 라이브러리는 유닉스가 오리지날.....ㅎ
	윈도우 특히 마이크로소프트의 사악한점은, 표준을 막 이것저것 변형을 해서 사용.... 호환성 문제가 생김..
	윈속 1.0,,, 윈속 2.0,,, 윈속 2.0을 사용하여 프로그래밍 하면 리눅스에서 돌리는 것은 포기해야함....ㅎ	
	그렇다고 호환성때문에 1.0 쓰는 거는 오바임... 30년이 넘음... 그 때하고 상황이 너무 다름.. Winsock 2.0! 을 사용해야함..!
	나중에는 리눅스 BSD 4.2 + 표준을 사용해야할듯...!
	WSAStartup(), WSACleanup(), 윈도우의 네트워크 표준은 괴상한 프로토콜 허접한 거였기 때문에, 이를 바꿔주기 위해 해당 함수를 호출해야함...! (호환성을 위해서..)

	///

	공유기 짜증남....	
	v6,,, 호환성때문에 아직도 v4에 뭍혀잇음...	

	h to n s()
	호스트 to 네트워크 short!

	WSABUF는 포인터를 통해서, 버퍼의 길이와, 버퍼의 포인터를 묶어놓은 버퍼임.!! WSARecv인 자에 , 버퍼 100바이트짜리 1개가 오면 1이 나와야함 !! 100이 아니다!!

	SOMAXCONN,,,!!! Listen에서 동접을 관리할 수 있음!!! 오 이걸 지금알았네!!!

	숙제 2!!!!	