게임 서버 프로그래밍 (03/14)
	원성연 (2013182027)

 저번 수업 정리
	Packet 받을때 크기 잘 맞춰서 받아야한다.
	Socket API를 사용할 꺼고, 


 Windows I/O 모델

	어떤 시스템적인 모델을 만들고 이에따라 해야겠다. 이래서 나온게 IO모델이에요.
	이 모델에 맞춰서 하는게 IO모델이에여요. 왜 이런 거창한 모델이 나왔나.
	클라이언트는 1대1인데 서버는 1대1이 아니에요...
	1개일때랑, 2개일때랑 차이가 커요...이게 몇천개면 훨씐 커요....
	다중 접속을 관리해야하기 때문에, 사용함.

	언리얼 기어즈 오브 워,, 같은 경우 1초에 20번 데이터를 주고 받아요...
	클라이언트는 서버에 필요할때마다 데이터를 줘요..
	서버는 클라이언트에 1초에 20번 보내요... 게임월드를 다 묶어서....
	대부분 실시간 게임들은 규칙적인 입출력 관리를 해요...
	매번 보낼때 똑같은 포맷으로 보내요( 게임월드 전체를 항상 동일하게 )
	
	그런데 우리는 그렇게 보낼 수 없어요.. 클라이언트가 8개 10개.. 오 현재
	지금 월드에 있는 모든 오브젝트를 모두 보낼수가 없음....

	FPS하던 방식대로 클라이언트에 보내면 안되고, 불규칙적인 상대처리를 해야함.

	
    I/O 모델이 필요한 이유
	- 비 규칙적인 입출력 관리.
	- 다중 접속 관리

    게임 서버의 접속
	- 정해지지 않은 동작 순서
		: 그래도 멈추지 않아야 하는 게임
	- 상대적으로 낮은 접속당 bandwidth...
		: 효율적인 자원 관리 필요...

	클라이언트가 데이터를 왔을 때에만 Recv를 해야함....
	근데 이거를 어떻게 아느냐!! 그거를 몰라요....
	근데 이건 알 수 이써요... 클라에서 보낸 데이터가 서버에 왔는지.
	안 왔으면 굳이 리시브할 필요가 없어요.. CPU낭비...

////////
서버 구현 방식 모델

	1. Socket Thread.... 안씀
		- Thread를 통한 처리.
		: 소켓 하나당 쓰레드를 하나씩 둬서 관리를 하자...
		1. 이렇게 하면 깔끔하게 서버 제작 가능하고, 딜레이도 없음.
		2. 다중 소켓 처리 가능
		3. 과도한 thread 개수로 인한 운영체제 오버헤드...
			-> 다음 쓰레드 어디로 갈까! 전환하는것도 0(N)이 걸림.
		4. 쓰레드 여러개면 메모리를 많이 먹음...
			-> 쓰레드 컨트롤 블럭, 스택에 쓰레드 만들떄 마다 쌓음.
			-> 스택 크기는 1 mb... 동접 5000이면 스택 5gb...
		5. 시스템 콜할 때마다, 오버헤드가 생김.
		6. 성능이 안나와서 망하고 , 디버깅하기 어려워서 망함.

	2. Non - Blocking I/O.. 안씀
		- 싱글 쓰레드에서, 논블로킹을 통한 해결.
		: 기다리지 않음... 에러를 리턴함..! WSAEWOULDBLOCK!!
		
		Busy Wait....
		CPU낭비가 너무 큼... Recv도 시스템 콜....

	3. Select
		Recv를 A를 해야하는지, B를 해야하는지가 문제잖아!! 고거를 물어보자!

		timeOut, 모든 플레이어가 멈춰있더라도, AI등 다양한 것들이 돌아가야함...!
		없으면 그냥 끝내라 0으로 설정해야함.

		- UNIX시절부터 내려온 고전적인 I/O모델
		- Unitx나 Linux에서는 socket 개수의 한계 존재, Unix : 64, Linux : 1024
		- socket의 개수가 많아질수록 성능 저하 증가.
			: Linear search를 함... 0(N)
		- 10개 쓰레드만들면 되지?? 로드 밸런싱..... 1서버는 라면다먹고 1서버는 다 게임함...????

	4. WSAAsyncSelect
		 비동기 셀렉트 (클라이언트는 이걸로 충분함)

		소켓 이벤트를 특정 윈도우의 메시지로 받는다.

		패킷이 올떄마다 메세지가 날라와서 거기서 처리하면 됨.
		-s : 소켓, -hWnd : 메시지를 받을 윈도우, hEvent : 받을 이벤트

		윈도우를 사용하면 되는데, 서버에서 윈도우 사용?? 오버헤드
		또 윈도우 메세지 큐를 사용하는데 성능이 느림..!

	5. WSAEventSelect
		윈도우 없이 돌아가는 ASyncSelect(4번꺼)

		소켓을 커널에 등록해서 데이터오면 알려준다...!
		아까 4번은 윈도우메시지인데 이거는 어떻게하느냐! 세마포!!
		두개의 다른 쓰레드, 프로세서가 서로 데이터를 주고받는거에요..!
		세마포는 데이터를 주는게 아니고, 데이터 왔다하고 알려주는 것!!
		세마포를 윈도우에서는 이벤트라고 부름.!

		엑셉트 될때마다, 세마포를 만들어서 등록을함...
		확인을 하려면, Socket와 event의 array를 만들어서, 
		WSAWaitForMultipleEvents()의 리턴값으로 부터 socket추출....

		세마포 60개 짜리를 만들어서 MultipleEvents를 보내면, 몇개가 나왔는지 알려줌..

		소켓의 개수 64개 제한...! -> 멀티쓰레딩 극복...!

	6. Overlapped i/O 모델 ( 비동기 I/O, Asynchronous I/O)
		Windows에서 추가된 고성능 I/O 모델...
		리눅스 - epoll
		OSX - kQueue
		windows - Overlapeed -> IOCP, RIO

		MS가 지어낸 썡뚱맞은 I/O에욬ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
		그래서 사람들이 헷갈려욬ㅋㅋㅋㅋㅋㅋㅋ
		메뉴얼을 봐도 설명이 되게 부실해욬ㅋㅋㅋㅋㅋㅋㅋ
		왜 이걸 안쓰느냐.... -> 메뉴얼을 봐도 설명이 부족해서..
		MS에서 이거 API만들었는데, 성능은 좋은데, 이상하게 만들어서 
		이 개색끼들은 욕먹어도 싸요....

		처음 접하는 사람은 되게 헷갈릴수 밖에 없어요....
		MS아니면 다 Asynchronous...!

		C++11 thread
		C++17 File I/O
		C++20 ASIO

		"<<" 이딴걸 쓰는거 말이 되요??? 볼때마다 짜증이나요...

		Windows::OverlappedIO, boost::Asio 어느것이 성능이 더 좋으냐,
		성능은 거의 동일해... IOCP는 boost::Asio로 안돼요..... boost::Asio가 좋긴좋은데 ㅠ

		대용량 고성능 네트워크 서버를 위해서는 필수 기능.

		동접도 많고 그럴떄는 필수임..!! IO모델.. 우리가 앞으로 배울 IOCP도 오버랩드 I/O를 사용함..
		무조건 IOCP를 사용함...

	1. 왜 이렇게 사용하느냐.
		
		동기 I/O
		패킷이 도착한 소켓의 리스트를 반환...!
		이 소켓의 리스트를 돌아가며 해당 패킷을 처리함..!

		비동기 I/O
		모두 리시브하고 엥 받아서 처리하고, 또 리시브하느거에욬ㅋㅋㅋㅋ

		동기는 Recv하고 쭈욱 대기....
		비동기는 Recv하고 다른일하다가 패킷을 받고, 버퍼에 데이터를 채우고 콜백!!

		커널한테 알림을 또 받아야함!

	2. 이게 왜 고성능이냐!

		동기랑 다른 것이 뭐가 잇느냐...!
		1.
		애는 버퍼에다가 받는데, 이게 돌아가면서 한번에 한 버퍼에만 데이터가 전송이됨
		근데 비동기는, n개의 버퍼를 커널에다가 다 등록해버리고, Parall하게 들어가기 때문에
		데이터 전송속도가 빨라요. 그리고 애는 데이터를 덜 사용해요...!

		2.
		동기는 커널에 있는 버퍼를 응용계층에서 복사받는 거에요...!!
		그러나 비동기는 커널 버퍼가 필요없고, 고냥 거따가 받는겨. 복사필요없이 쓸수있음..

		3. 비동기는 개수 제한이 없음....! 더 고성능임!!!
		
		메모리도 덜 쓰고, 복사도 덜하고, Parella하게 씀!!

	3. Overapped I/O 모델
		- 비동기 데이터 송수신을 할 수 있다.
		- 소켓 내부 버퍼를 사용하지 않고, 직접 사용자 버퍼!!
		- 받자마자 리시브!!!!
		- 리시브의 버퍼의 크기는 상당히 크게해야함!!!

		- 비동기 IO, Nonblocking IO과의 차이는?
			- 앞의 다중 I/O모델들은 recv와 send이ㅡ 가능 여부만 비동기
			- Overlapped는 여러 소켓의 send, recv 실행 자체를 동시에 수행.
		- 저부분이 WaitForEvent임!!	

		1. Send와 Recv를 호출했을 때, Send, Recv 함수 종료!!
		2. Send, Recv는 단순히 송수신의 시작을 지시하는 함수.
		3. 여러번 Recv, Send를 실행함으로 써, 여러소켓에 대한 동시 다발적 Recv,Send가 가능.

		
		이게 Overapped I/O에요!!

	4. 비동기 모델의 API 사용!!
		- WSASocket 생성 시, 마지막 flag인자, WSA_FLAG_OVERLAPPED로 해야, 오버랩드 I/O를 사용할 수 있음.
		- WSARecv 시, lpOverlapped 인자로 구분, 
				lpNumberOfBytesrecved를 NULL로 사용함.(데이터를 바로 받지 않고, 이벤트로 처리함)
				NULL이 아닐 경우, 바로 받을 수 있으니 절대 Null을 하면 안됨.
				lpCompletionRoutine : CallBack함수는 Null을 줌!
						여기에 함수 포인터를 넣으면 콜백방식으로 동작을 함!
		WSAOVERLAPPED 구조체!!!
			우리는 고냥 저거 사용만 하면 됨..! 하나 만들어서 주소르 넘겨주면 되여!!
			내부는 모두 0으로 초기화한 후 주어야함...!
			hEvent i/O가 완료 되었음을 알려주는 event핸들!
			
		- WSASend 시,	

	5. Overlapped 모델은 두가지 모델이 있음!
		Overlapped I/O Event 모델 (세마포어 최대 64개 밖에 안됨)
		Overlapped I/O Callback 모델

		a. event 모델 -> 못씀...! 세마포어!!
			1. WSAGetOverlappedResult()
			- Recv했어요. 여기 소켓 3, 여기 WaitForMutilpleEvent
			 어 여기 3이 리턴했어요... 버퍼를 읽어서 처리를 ㅐㅎ줘야해요...
			몇바이트가 왔다... 그게 없어요!! numOfByte 써주는데 이거 안써요...
			우리는 몇바이트왔나 이거를 따로 알아봐야해요 이게 GetOverlappedResult에요...

			
		PDF에 Overlapped I/O Event 모델 과정이있음!!!!!

		b. Callback 모델 
			- 이벤트 제한 개수 없음
			- 사용하기 편리
			- 함수의 포인터를 넣어서 사용
			- Overlapped i/o를 끝나면 함수를 실행함!!!

		그함수!! !void CALLBACK HaHA! (함수명 노상관)
		단 파라미터 타입은 지켜줘야함!!! 	 
		1. 작업의 성공 유무
		2. 몇 바이트 전송이 됬다!! 알려주는 것.!
		3. dwFlag는 쓸일이 없음!!!

		MS가 API를 발로 만들어서 의미없음..

		MAP하나 만들어서, 저거를 인덱스로해서 소켓번호를 알아내야하죠...!
		왜 저렇게 괴상하게 만들어났냐...!

		실습...!
