게임서버 4일차. 2019년 3월 19일

	 샘플 프로그램 보면서, 공부할예정. 샘플프로그램 kpu.ac.kr!!!! 꺼 받아서해 오진다리오진다리오진다.

	소켓 생성 시, 오버랩드여도 꼭 비동기로 쓰란 법 없음. Clinet는 굳이 IO모델이 필요없어요.

	소켓이 연결되지 않은 클라이언트는 클라이언트가 아니다.

	소켓 정보 구조체에서는 다음과 같은 데이터를 가져야 함.

	1. 일단 Send해야하고, Recv해야함. 이를 위해서는 버퍼가 있어야함..! 처음부터 버퍼를 갖고 있어야함!
		우리는 비동기 IO니까 버퍼가 처음부터 있어야함.
		Recv하고, Socket하고 동기식을 할때는 이 버퍼를 아무렇게나 해도 돼요. 
		work() {char[100]; , return } 해도 상관없음.. 그런데 비동기 방식에서는 이렇게 하면 클남!. 각 구조체마다 따로 갖고있어야함...!

		모든 소켓이 자신에 대한 버퍼를 가지고 있어야함...! 그렇기 때문에 버퍼를 소켓 인포에 넣는게 좋음... 안늘꺼면 따로 관리하던가...ㅎㅎㅎㅎ
		원래 비동기 IO를 한다... 원래 버퍼를 WSABUF를 가져야함...!! 우리는 윈도우 데이터 송수신을 하니까....ㅎㅎㅎ
		오버랩드 구조체도 각각 따로따로 갖고있어야함...!

		결론 소켓마다,  오버랩 구조체, WSA버퍼, 메세지버퍼를 가져야함...!


		우리가 게임을 만든다면, 클래스 플레이어를 만들고 그 플레이어의 포인트를 소켓인포에 넣을거임!!

	
	2. 그다음에 Map<Socket, SocketInfo> clients; 이 소켓은 어떤정보쓰고, 이소켓은 어떤정보쓰고!! 매핑이 되어 있어야함!!! 소켓으로 찾아야해!!

	3. 그다음은 콜백함수를 쓸거기 떄문에 콜백함수가 있어야함...!!

		void CALLBACK recv_callback(DWORD Error, DWORD dataBytes, LPWSAOVERLAPPED overlapped, DWORD lnFlags);
		void CALLBACK send_callback(DWORD Error, DWORD dataBytes, LPWSAOVERLAPPED overlapped, DWORD lnFlags);

		이름은 바꾸더라도 타입은 항상 동일해야함...!

	4. 오버랩드 IO의 콜백함수이ㅡ 파라미터가 뭐가있었어요??

		1. Error, NumofByte, Overlapped...가 있고, Overlapped에다만 넘겨줄 수 있음...!
			우리는 콜백을 사용할 거기 떄문에, 0 넣어야하는데, 거기다가 소켓을 넣을겁니다. 소켓을 넣어도 아무 상관이 없어요...

		2. 콜백 모드를 하면은 이벤트 뭐있는지 보지도 않고, 건들지도 않아요...! 어짜피 안쓰는거 소켓 정보를 넣겠다...
			플래그 우리는 아무것도 쓸거 없어요... 그렇다고 저기다가 0넣으면 에러임..., 오버랩드 IO와!!
			else...! 바로 오면 안되도록 NULL처리를 하면 절대 오지않아요!!!

		3. RecvCallback
			에ㅓ, 데이터바이트, 오버랩드, 플래그! 이렇게 받음!!

			SOCKET client_s = reinterpret_cast<int>(overlapped->hEvent); // 와 이거 오졋다.............! 인덱스임(Socket은 int임... 아무튼 인덱스임...!)
			
			C++11는 콜백을 리시브마다 다르게 줄수 있는데, 그거를 람다로 해결할수 있음...! 이런 지저분한 짓 안하고 할수 있음.......... 그러니 람다쓰세요....!!!!!!!!! 와우!!!!

			cbTransFeerd ...가 0이라는 뜻은...! 클라이언트가 종료했다고 보는 것이 옳음..!! -> 이건 리시브, 샌드 둘다 체크해줘야하는 문제임!!!!!!!!!!!!!! 나는 지금 리시브만 했잖어!!!!!
			WSABuffer의 크기를 받은 바이트로 바꾸고, Send를 함... 

			Send CallBack 마지막에는 RecvCallBack을 다시 호출해줘야함!!!

			억셉트.... 리시브...센드...!! 이거는 멀티쓰레딩 프로그래밍이 아니에요!!! 싱글 쓰레드에서 돌아가는 거임!! 우오오오오오오!!!
			멀티쓰레드 안하고, 싱글 쓰레드로 IO....!!!

			###### 리시브 상태에서 쌘드 기다리지 말고 즉시 받아야함!!!!!!!
			어 클라이언트가!!! Send한 걸, 처리하는 동안 못받죠!! 그러면 그만 큼 딜레이가 되는거에요!!!!!! 버퍼하고 오버랩드 구조체가 따로따로 있어야함!!!!!!! Send용 구조체 버퍼, RECV용 구조체 버퍼!!!

			
			Overlapped I/O는 뜬금없는 이름이고, 이를 사용하기 위해서는. 저 파라미터들을 세팅해야 오버랩드 IO가 동작을 한다...!!
	////////////////////////////////////

			Overlapped I/O 모델의 인자값 정리...!! !PPT꼭 확인하기!!!!! 

				hEvent에 쓰는게 바람직 하지 않음...! 나중에 저거에 따른 용도로 사용할지 모름....!! 

	////////// IOCP
			지금까지 우리는 다중접속을 구현을 했어요....!! -> 쓰레드 없이 비동기 I/O로...!
			졸작만들때 방금 사용한것으로 했을 떄 문제없이 돌아가요...!
			1, 2000은 쉽게 나와요....!

			동접이 5000~6000을 넘어가게 하려면 다른 방법을 사용해야해요!!!


			화장실 다녀옴....ㅠㅜㅠㅜㅠㅜㅠ

			보통 10일도 안되서....죽는데 머가??ㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠ

			IOCP도 콜백함수가 밀린다....! 그러면 동접을 줄여야함......ㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎ 대기표를 줌....ㅎㅎㅎ

			2014년까지는 최고의 모델이였으나, RIO가 나옴... IOCP보다 쪼금더 빠른데, 재는 문제가 로드 밸런싱이 까다로운 문제점이 있어서, 여기서 하지는 않고, 대학원가서 고급서버프로그래밍 다룰 떄 하도록 하겠어요...!
			근데 여러분들이 하는 게임들 거희 IOCP쓰지 RIO쓰는거 아직도 못봤어요....!

			Thread Pool에서 노는 애들 꺼내서 씀..!

			코어가 4개일때, 쓰레드 5개만들면 최대 4배 빨라짐... 쓰레드 10개만들어도 4배빨라짐....

			콜백함수를 호출할때, 윈도우 커널이 쓰레드를 만들어서 호출하는 것이 아님( 쓰레드 만드는 것도 오버헤드가 있음 _ 쓰레드 스케쥴링, 쓰레드 블록 등...),

			IOCP를 만들었으면 IO를 IOCP를 토앻서 해야함...! Send, Recv를 할 때, IOCP안에 있는 이벤트 큐에다가 Send, Recv를 등록해줘야함...!
			Send Recv를 할때마다 등록을 하는게 아니고, 소켓을 등록하면 알아서 IOCP의 등록이 되서 동작을 해요..

			그래서 IOCP라는 것이 있고, IOCP는 커널 교체에요....1
			커널에서 관리하는 클래스에요...! 클래스니까 오브젝트죠!!! 이런 비슷하넥 뭐가있죠?? FILE!! 커널객체죠??, 오픈하면, 파일의 배열이 있고, 이 배열의 인덱스를 리턴하죠??? (오 처음알았어!!!)

			IOCP를 사용을 한다, 그러면 아까 애기를 했던 쓰레드 큐, 가 여러개가 있고, 그래서 이 커널 자료구조를 통해서 읽고 써야하는데 직접은 못하고 Handle을 통해서 해야함...!


			1. Input Output compoletion Port...!! (IOCP 커널 객체 생성)
				만들때, 첫번째로, 1번 파일 핸들을 준다, 파일 핸들은 : INVALID_HANDLE_VALUE, 
					두번쨰로,  ExistingCompletonPort,...? 그딴거 업삳... NULL 넣어줘야해요...!
					3번째로, KEY!!! 숫자하나 넣어라 이런건데 고냥 NULL!!!!
					4번째로, 쓰레드 플에 넣을 쓰레드 개수가 아니고, 개수 제한 그딴거 아니고, 쓰레드 플에 쓰레드 여러개 있는데, 그 중에 최대 몇개를 꺼내서 사용할 것인가...? 이거는 코어의 개수만큼해야함...!
			
				코어 개수보다 쓰레드가 많으면 느려짐...! 콘텍스 싀위스팅...! 그러기 때문에 절대로 숫자를 쓰면 안되고, 0을 쓰면 안돼요!!
				는 아니고, 다른 쓰레드로 고정되서 하나의 코어를 사용하겠다!! 그러면, 여기에 -1씩 해저ㅜ야함.!!!!!
				그런거 아니면 닥치고 0을 넣어줘야함...!

				고냥 크리에이드 IOCP하면 되지,,, 왜 이따이로 API를 만들었느냐!!!! 이거는 빌게이츠 마음이에요..... 꼬우면 니가 운영체제 만들던가...!!

				IOCP가 어려워요....! IOCP 어렵다... 샘플 코드를 봐도 이게 무슨 소리인지 이해가 아노대요!!!
					그 이유 1. 엉뚱한 API - 이름이 근본없다, 파라미터가 근본이 없다. 
			
			2. IOCP를 연겨릉ㄹ 해줘야해요...!!
				소켓 자체를 IOCP에 연결을 하자...! Bind Socket을 해야함..!
				BindSocketToIOCP(s, hIOCP) --> 이런일을 하는 함수가 , CreateIOCompletionPort.....??? 이름이 왜 이래...?
				키값을 가지는데, 이 키값은 Unique하게 임의로 설정함...!!!

				IOCP 객체는 딱 1개만 사용함....! 뭐하러 두개를 써요?? 로드밸런싱문제도 생김...! 딱 하나만 써요...!
				특수한 경우 여러개를 사용하는데, 이건 성능하고는 상가ㅗㄴ없음.... 그런 삽질하면 안됨...!!

				여러분이 쓰레드를 만들어서 IOCP 큐에 넣어줘야해요...!!

			3. 어랴우 ㄴ이유중 또 하나에요... 그이유 2. 멀티쓰레드!!!
				쓰레드도 객체다... 고냥 저렇게 쓰면되죠??

				std::thread wth {WorkerThread};.... 근데 IOCPAddThreadPool 같은 함수가 없음... MS가 MS하다...
				GetQueuedCompletionStatus { }; 이거를 실행을 하면 IOCP에 등록이돼요!!

				hIocp, dwIOSize, key, ..

			4. Send Recv는 오버랩드 IO하고 똑같애요...! 이제 우리가 필요한 것은 call back 함수에요...! 멀티쓰레드 콜백!
				콜백함수를 등록을 해야하겟죠... 그네 콜백함수 등록이 없어요...!
				애 실행을 해서, 이 쓰레드를 대기 상태로 재워놓으면,, IOCP는 콜백 개무시헤요...!!!! flag도 개무시함!!!!!!!
				Key를 통해 소켓이 옴...!! 

				마지막으로 Send인지 Recv인지 알수가 없음...!!! send형 쓰레드, Recv형 쓰레드 따로 구분하지 않아요!!!
				따라서 lpOverlapped에 넣어야함...!!! !해당 이벤트에 넣는게 아님...! 

			5. PostQueuedCompletionStatus 
				이제 모든 퍼즐을 마쳤어요....!!

				IOCP가 어려운 이유 3 --> 너무 부족한 API..!

				여러분 프로그래밍할때, 절때로 이딴식으로 하면 안돼요.... MS니까... 꼬우면 하지맠ㅋㅋㅋㅋㅋㅋㅋㅋ
				이딴 운영체제에서 프로그래밍.....ㅎㅎㅎㅎ
				슬픈 현실이죠....?

				이게 뭐ㅏ냐....!!!!!!!! Get의 반대에요....!!!!!
				그냥 아무거나 넣고 호출하면 쓰레드하나 꺠워라!!!! 하면 서버 죽이는 용도....!!

				나중에 여기다가 의미있는 값을 정의해서 넣어서 따로 사용응ㄹ 할거에요...!!!!!! 
				
			 

			
			

	
