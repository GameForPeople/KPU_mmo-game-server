게임서버 9일차. 2019년 4월 4일

	IOCP 제작을 같이 했어요! 동접 10..! 을 넣고 빼고, 넣고 빼고했는데..
	우리가 IOCP를 하면서 멀티스레드 프로그래밍을 했어요.. 근데 뮤텍스를 하나도 쓰지 않았죠? 뮤텍스를 쓰지 않아도 멀티쓰레드를 하고, 잘 돌아가느냐? 아니에요...
	우리가 만든 서버는 버그 투성이에요...!

	지난 번에 했던 서버 잠깐 살펴보면, 여러분은, 자 우리가 서버를 만들 때, 흠... 쓰레드를, 여러 개 만들었죠?? 쓰레드를 여러개 만들었어요...
	이 여러개의 쓰레드에서 값을 일고 쓰고 하는데, 어 데이터 레이스가 없냐..? 아니죠? 전역 변수 읽고 쓰면 당연히 문제가 생기죠??

	먼저 g_iocp! 글로벌 iocp 핸들!! 이거는 아무 문제없죠?? 읽지 않고 쓰기만 하기 때문에 문제가 없음..!
	문제는 애에요..! Clients!! 자료를 읽고 쓰고 해요... 제대로 돌아가지 않고, 읽고 쓰기를 해요.
	어디에 데이터 레이스가 생기는지 알아보죠?

	이거(over), 읽어서 리시브를 하죠? 그러면은 억셉트 쓰레드에서는 애를 건들지 않고, 애는 문제가 안됨.
	소켓은, 애는 한번 만들어 놓으면 수정하지 않죠? 애는 문제가 안되고,
	패킷 버퍼애는 , 워커쓰레드에서 건들이는데, 두개의 쓰레드에서는 건들지 않으니 문제가 되지 않아요!

	문제는 connected와, x, y에서 발생함...!
	
	connected는 자기 자신이 아닌, 다른 애들의 것도 읽어요!, 안전하지 않아요!
	여기 있는 객체들을 읽고 쓸때, 락을 걸고 읽고 써야해요... 애 자체가 공유변수에요...! 당연히 락을 걸고 읽고 써야하고,
	제대로 하려면 어떻게해야하는가!!

	SocketInfo에 mutex,  access_lock을 걸어줘야해요...! 근데 여기다 락을 걸면, 병행성이 많이 떨어지겠죠?
	리시브 하느라고 막 쓸때, 딴 쓰레드가 읽기도 처리하기 어려움.....! 병행성의 의미가 많이 퇴색됨..!

	이런 문제를 어떻게 처리해야하는 가를 다루겠어요.


	수업시간에 여러분들 실습시간에 서버 프로그램 짜서 하고 있는데, 상용 서버에서는 제대로 돌아가지 않아요!!

	상호 배제가 제대로 되어 있지 않기 때문에,!!


	//자 그래서 이번 시간에는 뭘 해야 하는가, mutex없이 어떻게 프로그래밍 해야하는가!!
	
	DataRace가 지금까지의 모든 문제였는데, Lock 쓰면 속도저하, Lock을 덜 사용하도록 프로그램 변경 ( 변경은 힘든 작 업, Lock을 완전히 없애는 것은 힘들다)

	바뀔때마다 그때그때 전송을 해야 게임 실시간 서버이다. 반영된게 그대로 업데이트 되야지!!!!

	그럼 어떻게 해야할까, 쉽지 않아요, 어려워요!! 데이터 레이스가 완전히 없는 멀티 쓰레드 C 프로그래밍은 없어요..

		1. 정석  data race를 줄여서 lock의 필요성 자페를 줄인다.
			- 아무문제없다.
			- 효과 매우 크다.
			- 어렵다.

		2. 흑마법. data race가 있지만 전 후 사정을 잘 파악해서 lock을 넣지 않아도 잘 수행될수 있도록 프로그래밍 한다.
			- 효과가 있다.
			- 많은 함정들이 있다.
			- lock의 구현은 이 방법 밖에 없다.
	
			thread A // message = 10; ready = true;
			thread B // while(ready == false); cout << message;

			이러한 방법들을 뜻함, 데이터 레이스는 많지만 mutex는 없고, 정상적으로 동작함. 그러나 많은 함정들이 있음...!

			lock을 구현하기 위해 다른 방법을 고안해야함...!

	Lock 구현의 Starting point!
		1. 락은 공유 메모리를 사용해서 구현한다!
		2. 임계 영역은 반드시 한 쓰레드만 허가해야함!
		3. 가능하면 starvation도 없는 것이 좋겠다.
		4. deadLock이 없어야 한다.
		

	-----------------------------------
	예제를 한번 보자 [멀티쓰레드에서 락을 대신할 경우, volatile이 필요함! - 컴파일러의 최적화때문에 메모리를 잘 읽고 쓰지 않는다. ]
	
	//  이 코드가 정말로 문제가 없는가? thread A // message = 10; ready = true;  thread B // while(ready == false); cout << message;
		-> 문제가 있음... 컴파일 단꼐에서 문제가 생김...!
		-> 이런식으로 하면 안됨!!
		-> 그럼 여기다가 뮤텍스를?? -> 미친놈!

		-> 비주얼 스튜디오가 컴파일을 엉망으로 했으니 고소를 하자!
		-> 안됨, 원래 C에서는 while문에서 메모리를 읽으라는 조건이 없음.
		-> 비주얼 스튜디오는 C정의에 맟춰서 잘 만듬...!
		-> C는 원래 멀티쓰레딩용 언어가 아니기 때문에 메롱!
			
 		-> 정답은 다른 언어를 사용해야함!!! 은 저리가...!
		-> 정답은 volatile를!! 사용해!! (volatile는 읽고 쓸때마다 메모리에서 읽고 써라!!) (register라는 키워드도 있음! 이건 메모리 읽고 쓰는 작업이 없으니까 빨라!!)
			volatile 1. 반드시 메모리를 읽고 쓴다, 2. 변수를 레지스터에 할당하지 않는다, 3 읽고 쓰는 순서를 지킨다.
			원래는 volatile은 memory mapped i/o에 쓰는 거에요... i/o 장치에서 메모리 읽고 쓰는 거는, i/o 명령이 따로 있거나, 없거나...!! I/o의 읽고 쓰는 것을 확실하게 하기 위해 volatile!!

		-> Message와 ready를 volatile 키워드를 사용하여 선언함!! Message도 반드시 거기서 메모리를 읽는 다는 확신이 어려움...!

		디버그 모드에서는 이상이 없는데, 릴리즈 모드에서는 무한루프에 빠진다..... 여러분이 해결할 수 없어요.... 어셈블리를 공부해야해요...어떻게 컴파일했는지 확인을 해봐야해요....
		멀티쓰레드에서만 발생하는 버그이고,, 일반인은 알수가 없는 버그에요.

	-----------------------------------
	이제 정말로 잘 되는가? [포인터를 사용할 경우, volatile의 위치가 중요함! ]
	두번째 예!

	struct { volatile int data; volatile Qnode* next; } // 문제가 있음...!

	 volatile Qnode* next;
	*next = 1; -> 순서를 지킴
	next = otherNext; -->순서를 지키지 않음.

	int* volatile a;
	*a = 1;	--> 순서를 지키지 않음
	a = b; --> 순서를 지킴.!

	-----------------------------------
	그러나 이렇게 해도 다 잘된다고 보장되지 않는다... 피터슨 알고리즘, 베이커리 알고리즘, 데커 알고리즘..!
	빵집 알고리즘은 안할거에요 속도 성능 부화가 큼!!

	그래서 피터슨 알고리즘을 했는데,,,, 왜 안돼??? 그래도 나름 1억게 굉장히 근사하게 나왔는데ㅔ, 틀렷어요...!

	상호배제가 깨져서 상대방이 한 것을 덮어 쓴거에요....! 5000만번 중에 168번 오류가 생김..!

	25만분의 1의 학률로, 에러가 남...! 그리고 이게 굉장히 악질적인 에러...!
	여러번이 25만번을 돌려야지 1번 틀려요....! 게임서버 잘돌아가요, 클베 잘돌아가요, 오픈베타를 하는 순간 서버가 다운이 되죠...?

	이거는 25만번의 1확률로 디짐... 오픈베타할때만 디짐...! 버그가 있는 거는 확실한데, 프로그래밍을 아무리 쳐다봐도 버그가 없음... 교과서에 있는 프로그램임...!
	이러면 어떻게 해야해요...? 회사 망하는 거죠?? 

	다른 이유가 아님 버그 못잡아서 망함....

	이유는??
		1. 컴파일러는 문제 없다.
		2. 이유는... cpu...

		CPU는 out of order execution -> 다이나믹 ecoation + write buffer...
		CPU가 캐시가 꼬엿네.... 순서가 꼬이면서... 메모리에 버스 지나간 이후에 전달해버림...!

		이를 메모리 일관성 문제라고 한다! memory consistency problem!!

		이 문제는 싱글 코어에서는 절대로 들키지 않는다...!
		CPU에서 은폐를 함!! 다만 자기 자신만 할 수 있지, 옆에 코어까지는 못함...!
		메모리를 먼저 읽는게 아니고, 내부 CRP를 먼저 조지고, 그 이후에 없으면 메모리를 읽음!! 이를 전문용어로 인터널 포워딩이라고 한다.

		클럭속도 1000배인데, 성능은 50000배 정도 빠름...!
		LineBasedCache sharing, out of order execution, write buffering...!을 이래서 끌수가 없음..... 1 / 50 배의 성능이 됨....??? 멀티쓰레딩하려고 1 / 50한다고...?

	이거는 CPU 문제에서 해결해야함...!
		위에 최적화를 통짜로 끌수는 없고, 꼭 필요한 부분에서만 끌 수 있음...!

		_asm mfence --> 오버헤드가 엄청 큼!!! 파이프라인이 순간적으로 윽!
		이거는 mfence라는 명령어를 강제로 넣어주는 것!! (32비트 한정)
		64비트에서는 atomic_ ~~~를 사용해야함!!!


	문제는 메모리!

		프로그램은 순서대로 읽고 쓰지 않는다. 이 뜻은, volatile로도 해결되지 않음을 뜻함...!
		막 별 이상한 일드링 일어날 수 있는데, 제대로 동작하는 프로그래밍을 해야한다...!

		싫으면 그러면 고냥 mutex를 사용한다.....


	해결책은!
		1. mfence를 잘 사용하자...! 알고리즘을 잘 보다가 여기 여기 문제가 있으면 큰일나는 구나! 이런 곳에 서야함...!
			a. 아 내가 짠 프로그램이 모든 out of exception에서 잘 돌아가는 것을 증명을 해야 확신을 할 수 있고, 그렇게 해야해요...! 클베까지 죽지 않던 프로그램이 오베때 죽어요....!
		2. mutex 떡칠, 동접 2000 어떻게 해요...? --> 욕좀 먹고 동접이 떨어지는게 서버 처지는 것 보다 나아요!


	-----------------------------------
	메모리 일관성 테스트 2

	다음시간에 아래 코드 함!!
#include <thread>

#include <iostream>
#include <atomic>

using namespace std;

volatile bool done = false;
volatile int *bound;
int error = 0;

void worker()
{
	for (int i = 0; i < 25000000; ++i)
	{
		*bound = -(1 + *bound);
	}
	done = true;
}

void inspector()
{
	while (false == done)
	{
		int t = *bound;
		if ((t != 0) && (t != -1)) error++;
	}
}

int main() 
{
	int a = 0;
	bound = &a;

	thread c{ worker };
	thread p{ inspector };

	c.join();
	p.join();

	cout << "Num error : " << error << std::endl;
	system("Pause");
}

	
메모리 일관성 1번 문제에 적용된 락!

volatile int victim = 0;
volatile bool flag[2] = {false, false};

void p_lock(int myid)
{
	int other = 1 - myid;
	flag[myid] = true;
	victim = myid;
	_asm mfence;
	//atomic_
	while ((true == flag[other]) && (victim == myid));
}

void p_unlock(int myid)
{
	flag[myid] = false;
}
				
	
