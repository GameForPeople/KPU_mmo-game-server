게임서버 9일차. 2019년 4월 9일

	멀티 쓰레드 2
		- Lock이 없는 프로그래밍

	Lock이 있으면 프로그래밍이 깔끔해져요. 항상 옳은 결과가 나오고 해서 우리는 락을 빼야하는데, 빼면 무슨 일이 벌어지는가!

	1. 지난 주
		데이터에다가 1을 넣고 전달을 하는데, 간단한 로직인데도 돌아가지않음, 왜냐하면 컴파일러가 최적화를 한다는 측면에서 한번 읽고 뺑뻉 돌아요...!
		그래서 우리는 Volatile 을 써서, 읽을 때 반드시 읽도록 만들어야 해요.
		비주얼 스튜디오가 컴파일할 때, 잘못하는게 아님!

		또 경우에 따라서, CPU 마음대로 뒤죽박죽 실행하는 경우가 있음, 이로 인한 문제는 10만분의 1, 100만분의 1으로 오픈 후에 1시간 간격으로 터짐...! 미리 알 수 없으며, 에러가 제현도 안되고, 디버그로 봐도 값이 찍힘!
		따라서 이를 중간 중간 억제할 수 있도록, _asm mfence(windows x86),  std::atomic_thread_fecne(std::memory_order_seq_cst) [C++11] <- 이친구로 쓰면 리눅스에서도 돌아가고 x64에서도 돌아감!!! < 다른 옵션 쓰면 안됨 >

		락이 없이 뇌피셜로만 하면 현실은 이런 문제가 있다!


	1. 중간값 ( 초기값 ) // 4바이트 안정성!!
		- 초기값이 있고, 중간값이 있고, 최종값이 있는거에요.
		 0에서 -1로 바꾼다면, 0이 초기값, -1이 최종값, 


	여러분 겈퓨터 안에는 코어가 있고, CPU도 있죠, 코어안에 뭐가 있어요 캐쉬가 있어요...!
	모든 메모리으 ㅣ리드 와이트는 캐쉬에 올려놓고 한다.
	캐쉬를 읽을 때, 캐쉬는 라인단위로 간다. 캐쉬에 있는 모든데이터를 태그 (주소)를 가져야한다..
	배 보다 배꼽이 크져?? 캐쉬라인!! 캐쉬라인은 꽉차있어야함!!! 메모ㅣ를 읽을 때 한번 읽고 있으면 문제가 없어요.

	캐쉬라인 읽고 쓰는거는,  중간값이 나옴...!
	자 우리가 두바이트씩 잘랏끼때문에 16비트 씨 ㄱ나오죠??

	캐쉬라인 걸쳐있기 때문에, 앞에 24바이트 밖이는거!!

		대책은?
			1. Byte 밖에 믿을 수 없다.
			2. Pointer가 아닌 변수는 Visual C++가 잘해준다.
			3. Pointer를 절대 믿지 마라. (멀티 쓰레딩을 할 때, 그냥 변수가 아니라 포인터를 통해 주고받으면, 4의 배수인가 아닌가를 확인해야함...! 4의 배수가 될 수 있도록!)
			4. Pragma pack을 조심하라! 버퍼의 패킷 어디에, 인티저의 위치가 걸치지 않는다, 보장이 없죠?
				위치지정할 때, 데이터가 4의 범위가 되도록!!


	따라서 캐쉬가 문제다...

	락이 없는 멀티 쓰레드를 할 때 아래의 4가지 문제가 발생함!!(소스코드를 아무리 들여다봐도 원인을 알 수 없음. 디버그로도 알 수 없음!)

		1. 컴파일러가 문제다. (볼래타일 붙여야함, 귀찮으,ㅁ 복잡함, 최적화안되서 속도가 떨어짐 -> 따라서 공유 메모리 뭐에만 쓸것인가 해야함)
		2. CPU가 문제다 ( 꼭 필요한 곳에만 fense를 붙여줘야함!! )
		3. 공유하는 데이터는 캐쉬 메모리 바운드에 바운딩되지 않도록, 팩같은거 쓰지않도록 해야함!
		4. ABA 문제! -> 멀티 코어시간에 다룰 예정!!
		5. 없음! 끝! 오케이! 이게 다니까! 하지만! 하나하나가 굉장히 까다로움! 

	락을 안쓰는 것은 정말 조심해야해요.....!

	// 그래도 희망적
		1. 언젠가는 메모리에 대한 쓰기가 실행 된다.
		2. 자기 자신의 프로그램 순서는 지켜진다.
		3. 캐시의 일관성은 지켜진다.
		4. 캐시라인 내부의 쓰기는 중간 값을 만들지 않는다.

		메모리가 이러니까 이거에 맞게 프로그래밍 하라! 사람의 머리가 이걸 이해할 수 없음............못해요! 사람은 모든 메모리를 읽고 쓰는데, 이거를 할 수 없음..

		강제로 맞혀야함..!!! 성능저하가 생김...! 어려운 프로그래밍(희망적 프로그래밍을 쓸 것인가) , 성능 저하가 있는 방법을 쓸 것인가 -> 정답은 성능 저하가 생김!!!
		-> 그래도 락보다 빠름!! 그니까 써!!,,,, 

	x86에서는 E만(교수님이 보여주신 경우의 수들!!) 일어남...!

	

	결과

		1. 이러한 상황을 고려하면서 프로그래밍을 한다.
			- 가능하지만 프로그래밍이 너무 어려워진다.
		
		2. Lock을 넣어서 순서의 어긋남을 제거한다.
					
		3.

	 	4. 기존의 멀티쓰레드용 라이브러리를 사용한다.
			c++11 <atomic>
	
	메모리 Read Write을 atomic하게 해야겠다.
		쓰레드 접근의 절대 순서가 모든 쓰레드에서 지켜지는 자료구조를 atomic 자료구조라고 한다.
		싱글 코어에서는 모든 자료형이 atomic하다.

	Atomic 자료형을 사용한다.
		SW적으로 구현 할 수 있음 : int는 atomic이 아닌데, atomic_int를 구현할 수 있는가, -> 있는데, 대학원에서 배움...!
		HW로 구현되어 있음 : c++11의 atomic을 사용할 수 있다.

		중간에 다른애가 끼어들지 않는다!

		다만 Atomic + atomic은 아토믹하지 않다. 멀티쓰레드에서는 이런것도 주의해야한다!
			sum += 2 ; // sum.add(2);
			sum = sum + 2; // sum.write(sum.read() + 2);

		atomic은 내부적으로 mfence를 사용함...! (똑같은거는 아니고, 기능이 유사함)

		다만 기본자료형이 아닌, 다양한 자료구조를 구축하여 사용해야함...!
		atomic Memory를 사용하여 자료구조를 만들면 atomic한가? --> NO!!!!!
		
		효율적인 Atomic 자료 구조가 필요하다.
			1. 일반 자료구조에 Lock을 추가하면 ---> 너무 느리다!
			2. STL에 큐는 멀티쓰레드에서 쓰라고 나온 자료구조가 아니에요...! 
			3. STL + Lock은?? --> 느려서 못쓴다...!

		Lock이 없는 자료구조!! Lock이 Mutex죠??
			우리가 큐를 구현하는데, 일단 인큐, 디큐, ...?
			인큐, 디큐 내에 뮤텍스를 안쓰고 빵집알고리즘을 사용함...! (그래봐야 어짜피 상호배제라 성능 오바...)
			결과적으로 상대방 쓰레드와 관련없이 구현되도록 해야함!!

		따라서 블럭킹되지않는 자료구조가 필요함...!
			넌블럭킹!!
				우리 메모리 읽고 썻죠!! 메모리 읽을 때, 락을 걸지 않고, 읽고 써야함!! 옆의 쓰레드가 갖고 있든, 없든, 읽고 써요! Interlocked Oeration!!!

			Priority Inversion! : Lock을 공유하는 덜 중요한 작업들이 중요한 작업의 실행을 막는 현상!! 우선순위가 낮은 애가 안비켜줘요!!!!!
			Convoying! : 쓰레드 자체는 문제가 없는데, 운영체제에서 스케줄링할때, 코어의 개수보다 쓰레드 개수가 많으면 운영체제에서 타임 쉐어링을 해야함!!
					( 락을 했는데, 스케쥴링애서 쫒겨남.... 와우 언락도 못했는데 쫒겨나면 오바여....)

		Wait Free - Lock Free 기법을 사용해야함!!
			넌 블럭킹의 등급
				- 무 대기 (wait Free)
					: 모든 메소드가 정해진 유한한 단계에 실행을 끝마침
					: 직관적이고 성능도 좋은 알고리즘!

				- 무 잠금 (lock free)
					: wait Free 가 좋은데 만드릭 ㅣㅎㅁ들음...
					: 정해진 시간에 끝나는게 아니라, 조금 밀릴 수 있음... 계속 충돌하면 기아 (starvation)을 유발하기도 한다.
					: 충돌했을 때, 2중 1개는 무조건 실행을 끝마침..!
					: 성능, 프로그램 구현 난이도...!

				절대로 락을 사용하지 않고, 다른 쓰레득 ㅏ어떠한 행동을 하기를 기다리는 것 없이, Atomic하게 알고리즘이 돌아가야함!

		Atomic Memory로 non-blocking 자료구조를 만들 수 있는 가? --> 아니다. 못만든다라는 것이 증명이 되어 있음....!!

			CAS를 써야한다!!! ( CPU로 명령어로 구현이 되어있어야함!!)

			MEM.CAS(A,B); MEM의 값이 A면 MEM의 값을 B로 바꾸고 true를 리턴.
					MEM의 값이 A가 아니면 아무것도 하지않고 false를 리턴.

			lock cmpxchg [A], b 기계어 명령으로 구현(x86)

		실제 CAS는 C++11에 구현되어 있음!!

		- Atomic_compare_and_set은 없고, atomic_compare_exchange를 대신 사용!!! atomic_compare_exchange_strong !! 왜 스트롱이는!! 
		win32 API는 고냥 무시해버리기!!!

		CAS가 구현되어 있으면!!  상호배제가 됨!! (빵집알고리즘, 데커알고리즘 커졍!!)

		void Lock(atomic_int * x)
		{
			while(false == CAS(&X, 0, 1));
		}				

		void Unlock(atomic_int *x)
		{
			x= 0;
		}	

		CAS의 위엄!! CAS를 사용하면 여러부느이 모든 프로그램을  wait-Free하게 바꿀수 있음.. 증명가능!!
		 CAS 최적화를 우리가 할 수 없음.... 원래는 Lock을 써야함.... 안쓰도록 최대한 설계하지만 써야되면 어쩔수 없이 Lock을 써야함...!
		PPL, TBB(Thread Building Block)



		고성능 멀티쓰레드 프로그래밍이 무엇이냐!!
			비멈춤(논 블로킹) 자료구조를 사용한 프로그래밍...!, Lock은 사용하지 않지만 CAS는 필요하다. (증명되어 있음)


		논 블로킹 프로그래밍이 괴앚ㅇ히 어려운 프로그래밍이에요....! 성능이 진짜 100배 차이남...!!!

		정리

		멀티 스레드 프로그래밍은 공유 메모리를 사용해서 스레드 간의 협업을 한다.

			data race로 인한 잘못된 결과
				- data Race를 없애는 것은 Lock이 기본!
			Lock으로 인한 심각한 성능 저하! 
			Lock을 제거
				- 직접 공유 메모리를 사용했을 때, 생기는 문제
					: 일관성, 중간 값

			Atomic 한 공유 자료 구조를 만들어서 사용하는 것이 좋다.
				- 아이온 15000! 동접이 ㅏㄴ옴!!!

		교수님이 아는 사람들 연봉 2억씩 받음....!


---------------------------------------------------------------------

	지금까지 우리는 프레임워크를 함!!

	게임서버는 코어하고, 콘텐츠로 이루어져 있음!

	우리가 지금까지 만든 것은 코어임!

	코어는 쓰레드, 네트워크, 클라이언트 자료구조,

	이제는 콘텐츠를 만들어야함!!!
		- 앞으로 게임 콘텐츠 어떻게 해야할까?
		- 데이터 베이스에 어떻게 연동해야 할까?
		- 스크립트하고 어떻게 해야할까?
			- 스크립트 언어 : 생산성...!

	아무 플레이어도 보지 않는 월드는 시뮬레이션 안해도 되는데 그럴일이있나...?
	메모리에는 다 올려놔야함!! 시뮬레이션 CPU를 돌리는 것은 보이는 것만 하면 되죠?? 안보이면 멈춰도 돼요!! 실제로 그렇게 많이 해요!! Sclae을 따져보면서 해야함!!!

	 