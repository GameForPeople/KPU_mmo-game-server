게임서버 6일차. 2019년 3월 26일

	저번에 배운 것!
		지난 시간에 우리가 IOCP에 대해서 했어요.
		음....쓰 지난시간에 윈도우 IOCP 모델에 대해서 설명을 하고 IOCP를 사용한 서버 프레임워크에 대해서 애기를 해줬죠?
		메인함수가 있고, 그리에이트 IOCP하고, WOrker 쓰레드 만들고 억셉트 쓰레드 만들고, 그러면 끝나는 거고, 
		억셉트 쓰레드는 바인드 리슨 억셉트하고, 그 다음에 IOCP에 createIOCP해서 억셉트에서 나온 소켓을 등록을 한다음에, 리시브하면 끝이다.
		워커 쓰레드는 무한 루프 돌면서, GetQueuedCompletionPort를 호출하고, 리시브이면 패킷 재조립을 한다음에 프로세스 패킷을 처리를 하고,
		센드면 딜리트 오버랩드 구조체!

		이게다다, 이건 서버 프레임 워크이고, 게임 콘텐츠를 집어넣어야 게임 콘텐츠가 될텐데, 프로세스 패킷 여기다가 집어넣으면 되죠? 
		서버가 갖고있는 상태를 변경한다거나, 아이템을 변경한다거나, Send!해서 상태를 전송해야함...!
	
	오늘 살펴볼 것!
		멀티쓰레드!

		CPU가 너무 느리기 때문에, 멀티쓰레딩이 필요함.

		프로세스 : 실행 중인 프로그램
		쓰레드 프로그램의 흐름.

		프로세스가 있다 그러면 프로세스는 데이터, 코드, 스택, 힙 이렇게 4개로 구분되는데, 쓰레드가 생성되면 쓰레드 스택 하나가 생성이 된다.
		프로그램을 실행시키면 기계어가 CODE에 로딩이 되고, DATA에는 전역, HEAP에는 동적메모리, STACK에는 정적메모리, 리턴값등...!
		CPU는 레지스터 값을 갖고 실행하고, 이 레지스터 값은 PCB에 있음...! SP 스택포인터와 PC ...등!

		멀티쓰레드는 프로시저 컨트롤 블럭안에 쓰레드 컨트롤 블록등이이 있고, 각각 컨텍스트를 갖고 있음..!
		여기의 SP는 각각의 스택을 가르키고, PC는 코드를 가르침...!
		코어 개수보다 쓰레드가 많으면, 속도가 빨라지지않음...!

		따라서 쓰레드끼리 지역변수는 따로 가짐...!!


			장점 : 
				1. 성능 향상, 
				2. 빠른 응답 속도, 
				3. 더 나은 자원 활용, 
				4. 프로세스보다 효율적인 통신!!, 콘텍스트 스위칭!! (프로세스 끼리 통신하려면 메세지해야함...시스템 콜!)
			단점 :
				1. 프로그램 복잡도 증가
				2. 디버깅의 어려움 (data race, deadlock) - 제대로된 프로그램을 짜기 어렵다.

			예 : 리니지, 리니지2, 아이온, 리니지2 레볼루션, 아키에이지


		멀티쓰레드 프로그래밍에는 2가지 스타일이 있음.

			- 헥터러지니러스
				: 작업을 쪼개서 종류별로 다른 쓰레드에게 맞기는 스타일 - 클라이언트
				: 바틸렉이 발생할 수 있음....!!!
			- 호모로지니러스	( 이벤트 드리분, 데이터 드리븐)
				: 작업을 쪼개서 쓰레드 구분없이 나누어 하는 스타일 - 서버
				: 성능이 더 좋을 가능성이 큼...!

		
			주의 점 :
				- 쓰레드의 개수가 많다고 좋은 것이 아니다.
				- 프로세서/코어이ㅡ 개수에 맞추어라. 1.5배에서 2배를 만들어라..!
				- 운영체제 및 하드웨어에 부담 : cache
				- Data Race, Single Core Computer에서도 조심...!


		윈도우에서의 멀티 쓰레드 프로그래밍...!
			- 기본이 멀티쓰레드 운영체제기 때문에, 다른 짓이 필요없음. 하나만 일하고 다른 코어들은 놀고! 이런일은 절대로 일어나지 않아요!
			- Affinity 적용...! 어떤 쓰레드를 담당하던 코어가 지속적으로 그 쓰레드를 담당할 수 있도록...!

			쓰레드의 문맥 전환 ( 이 쓰레드는 운영체제가 컨트롤 해요...! )
				쓰레드느 유저레벨 쓰레드가 있고, 커널레벨 쓰레드가 있는데, 윈도우는 커널레벨 쓰레드임...

			우리는 윈도우 고유의 Thread API를 사용하지 않고, C++11의 표준을 따르는 프로그래밍 방식을 사용할것임!!!
			( 윈도우도 되고, 리눅스도 되고, 안드로이드에서도 되기 때문에, C++11의 쓰레드를 사용할 것임)

			std::thread th1 {th_Function}; //  쓰레드 생성..!
			th1.join();	// 쓰레드의 종료를 확인해야함...! 쓰레드는 강제 종료가 안되니까 기다려야해서 join해야함...!

			쓰레드를 생성하면 초기에 보조 쓰레드를 생성할 수 있음... 이거는 이 후 알아서 저일됨...!!!


		멀티쓰레드 프로그래밍을 했으면...! 항상 성능 향상을 확인을 해야함...!!
			chrono 라이브러리를 사용함...!


	멀티쓰레드 프로그래밍이라는 것은 락을 최소화하고, 동시에 실행하는 부분을 최대한 느리도록(?) 작성을 해야함!!


		

				
	
