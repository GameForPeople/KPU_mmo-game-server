게임서버 5일차. 2019년 3월 21일

	 Overlapped I/O Callback을 멀티쓰레딩 환경에서, 고성능으로 돌아가게 만드는 모델인 IOCP를 저번에 배웟음.

	
	오늘 살펴볼 것!
		1. IOCP 서버 프레임 워크
		2. 멀티 쓰레드 프로그램이 무엇인 가
		3. IOCP 서버 실습.!!


		1. IOCP 서버 프레임웤

			어떻게 생겻나 보면은, 일단 IOCP 객체를 만들고, 그 다음ㅇ ㅔ쓰레드를 만들고 억셉트를 받고, 리시브를 하면서 동작을 해야해요. 그 프레임웍을 어떻게 해야하는가

			일단 IOCP API는 두개가 있다고 했죠?? 원래 4개가 필요없는데, 근본없이 두개로 줄임.. GetQueuedCompletionStatus() 두개를 하나로 줄였는데 이거는 잘했다.. 시스템 콜 1번..

			1111
			서버 설꼐
				- 일단은 IOCP 핸들을 생성하고
				- Thread를 IOCP Thread Pool에 등록 
					(당연히 Accept thread보다 먼저 만들어져야함)
					(이 thread를 Worker Thread라고 명하고, 이거는 전통이야 씹새야)
				- Accept Thread 생성 
					( Accept 무한 루프 )
					- 별도로 하나의 쓰레드를 두느냐, 메인 쓰레드에서 하느냐, 이렇게 쓰레드를 따로 만들면 메인 함수가 굉장히 깔끔해 지겟죠?? 
					쓰레드 만드는게 좋은 선택은 아닌데, 어짜피 워커쓰레드 만들거 고냥 하나 더 만들어서 깔끔하게 히ㅏㄹ거고.

				
			
				1. Accept thread는 뭐냐!!
					- 새로 접속해 오는 클라이언트를 IOCP로 넘기는 여고할.
					- 클라이언트가 접속해올때까지 기다렸다가, Accept에서 소켓이 나오면, 어 새로운 클라ㅣㅇ언트가 접속을 했네, 클라이언트 정보 구조체를 만든다.
						- 클라이언트 정보 구조체에 체력등과 같은 정보를 두는 것이 옳음..!!
					- IOCP에 소켓을 등록한 후, WSARecv()를 호출한다...!
					- Recv가 완료되면 즉시 즉시 Recv를 해야함!!!


				2. 클라이언트 객체
					- 서버는 클라이언트 정보를 갖고 있는 객체가 필요.
						: 최대 동접과 같은 개수가 필요.
						: 필요한 정보 : ID, Socket, 상태, 게임정보 (name, HP, x, y) 등등!!

					- GetQueuedCompletionStatus 리턴값은 불리안...! 파라미터는 핸들값, 바이트 크기, Key, overlapped 등등...
					- 보통 Completion_Key를 클라이언트 객체의 포인터 or 클라이언트 객체 ID or index로 한다...!
					- Key를 갖고 우리는 어떻게 클라이언트 객체를 찾을 것인가...!
					- 우리는 배열에 선언하고, 배열을 index로 하고, 이 index를 키로할 예정임
			
				3. Overlapped...!
					- 모든 Send, Recv는 Overlapped 구조체가 필요함.
					- 하나의 구조체를 동시에 여러 호출에서 사용하는 것을 불가능...!
					- 소켓당 Recv호출은 무조건 한 개여야 한다...!
					- 소켓당 Sendㅎ호출은 동시에 여러 개가 될 수 있다.
					
					따라서, Recv용은 무조건 한개가 있어서 계속 재사용하는 것이 바람직함...!!!!!!!!
					그러나 Send는 몇개를 보낼지 모름....오바긴한데 Send할때,  New  Complete되었을 때, delete !!!!
				
					Send, Recv를 할때, 버퍼도 동일함... 이 버퍼는 여기서 재사용가능하죠???

					성능을 위해서는 공유 Pool을 만들어서 관리할 필요가 있다...!!!
			
				
				4. Send인지, Recv인지 알기 어려움...! 이 정보를 우리가 넣어ㅜ저어야 함...!
					Listen Socket을 IOCP에 등록시켜놓으면 Accept도 알아야함...!

					Overlapped i/o 구조체 디ㅜ에 더 추가하면, IOCP는 있는지 없는지도 모르고 에러도 나지 않음...!!!!!
					절대 건드리지 않음!!!!!!!!!!!! 메모리 오버플로우 남..!!!
					
					다른 방법으로는 소켓 주소 구조체의 가장 위에, Overlaaped 구좊체를 넣으면 됨!!!!

				5. Worker Thread
					무한루프 돌면서, 콜백을 실행함...!

					GetQueuedCompletionStatus를 부른다.
					에러 처리. 접속 종료 처리를 한다.
					Send/Recv 처리를 한다.!!!

					Recv 
						패킷이 다 왔나 검사 후, 다 왔으면 패킷 처리.
						여러 개의 패킷이 한번에 왔을 떄 처리.
						계속 Recv 호출

					Send 
						Overlapped 구조체, 버퍼의 free(혹은 재사용)

				.... 서버 프레임 웍 완성..!!

				메인함수
					1. IOCP 핸들 생성
					2. Worker thread 생성 및 넣어주기
					3. Network 초기화 및 Accept

				Accept
					1. 엑셉트
					2. 클라이언트 구조체 생성
					3. 소켓 IOCP에 등록
					4. 리시브

				Worker Thread
					1. Recv Or Send!!!

			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			버퍼 관리, Recv 
				1. 패킷이 날라왔어, 패킷 처리하고, 
				2. 다시 리시브.....
				
				그러나 현실은, 두 줄에 끝나지 않고, 패킷이 여러개 있을 수 있고, 중간에 짤려 있을 수있음.
			
				예) 클라이언트가 서버에 패킷을 보냄, MovePacket, ChatPacket, MovePacket, AttackPacket
				
				그런데 버퍼에 어떻게 들어있는가,!! 지맘대로 들어올수가 있음....!! 분리된거 저장해놨다가 합치고, 골라내서 처리해야함...!

				물론 고정으로 해도 되는데,,,, 오버헤드가 크죠??? 한번에 받아서 처리하는게 효율적이에요...!
				그러니까 우리는 재조립을 해줘야함...! 버퍼에 들어있는 패킷을 재조립을 하늗네 프로그래밍이 좀 복잡해져야해요...

			버퍼 관리, Send
				1. 하나의 Socket에 여러 개의 send를 동시에 할 수 있다.
					- 멀티 쓰레드!
					- overlapped구조체와 WSABUF는 중복 사용 불가능...!!
					- 동시에 Send해도 절대 안섞임...!!

				....... 내부 버퍼가 꽉 찼을 때는.... 노답임..........ㅎㅎㅎㅎㅎㅎㅎㅎ 내부 버퍼는 무한대인데....?? 내부 버퍼가 꽉찼다는 것은 메모리가 끝짱났다는 뜻...!!
				이거는 고냥 서버가 죽을 지경이라는 뜻.....! Send가 문제가 아니얔ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 이미 끝난거에요.... 서버 크래쉬에요......
				리부팅해야함........ㅎㅎㅎㅎㅎㅎㅎ

				1. Send를 할 때, 모아놓고 차례차례 보내면서, 버퍼를 쌓아 놓고, Send가 다 끝나면 다음 Send보내고, 다음 Send보내고.... 절대로 이렇게 하지 않음!!
					(성능에 도움이 안됨...!)
				2. 내부 버퍼를 비우면, 되지 않을까....? 그 소켓을 끊어 버림......ㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎ그래봤잨ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ


				이런 일 자체가 안벌어지게해야함......! 대학원가면 어떻게 이걸 막을 수 있을 것인가... 메인메모리가 5gb이다, 1 소켓이 메모리 1mb이상을 쓰면 안되죠??
				끊어요... 동접을... ㅎㅎ 서버가 다운되는거 보다, 클라이언트를 고냥 날려버림....ㅎㅎㅎㅎㅎ

			먼저 할 일
				- 다중 접속 관리
					클라이언트 접속 시 마다 ID 부여...!! ID 재사용 동작에 대한 정의도 해야함....!

				- 패킷 포맷 및 프로토콜 정의 (문서화해야함!!!, 밝혀서 혼내줘야함....!!)
					1. 기본 패킷 포맷
						- 길이 (Byte) + 타입 (Byte) + Data(...) -> 재조립을 하기 위해서는 길이가 꼭 필요함....!
					2. client -> server
						- 이동 패킷
					3. server -> Client
						- 위치 지정, ID 접속알림, ID 로그아웃 알림...!

						CS 구조가 다름...! 어떤 순서로 할 것인지...!

						Id, PW 보내줌 -> 맞아 너 정보는 이거야, 아닌야 까ㅓ져!!!!!

					4. 시퀀서도 포함해야함...!!


				- bool PacketProcess()

				Recv의 구현...!

				모든 데이터를 처리했으면 GOTO 종료...!
					남는 데이터로 패킷을 완성할 수 있는가?
						예, 패킷 버퍼 완성, 패킷 처리 함수 호출
						아니오 : 남는 데이터 모두 패킷 버퍼로 전송

					goto start

				와 이가ㅓ 오진다 오진다 어ㅗ져 2-58 진짜 오진다고 오져 이거 다시 꼭봐 미쳣다 진짜 오졋어.....

				WSA Send!!
				Send는 여러 thread에서 동시 다발적을 ㅗ발생...! 


////////////////////////////////////////////////////////////////////////////////////////////

		쓰레드 만들기!! 멀티쓰레드 - 1

		병렬 처리
			- 멀티 코어 / 멀티 CPU 활용...!

		프로세서 콘트롤 블럭에, 콘텍스트가 여러개 있는것, 이거 하나하나가 쓰레드이고, 이를 쓰레드 콘트롤ㄹ 블럭이라 부름...!

		각각의 콘텍스트에서 PC, SP 등이 있는데, PC는 code를 가르키고, SP(스택포인트)는 스택의 위치를 가르침...! -> 이거 다 레지스터의 갑싱여...!

		멀티쓰레드 프로그래밍은 되도록 안해야함.... 안해도 되는데 한다... 정신나간일...! (멀티쓰레드 피하려고 Overlapped I/O 가 나온겨!! 오오오오!!)

		


				
	
